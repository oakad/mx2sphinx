// Reimplementation of SGI's rope class -*- C++ -*-

// Copyright (C) 2010 Alex Dubov <oakad@yahoo.com>
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3, or
// (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.


// Derived from original implementation
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
// Free Software Foundation, Inc.

// May contain parts
// Copyright (c) 1997
// Silicon Graphics Computer Systems, Inc.

// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear
// in supporting documentation.  Silicon Graphics makes no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied warranty.

#ifndef _EXT_ROPE
#define _EXT_ROPE 1

#include <iterator>
#include <counted_ptr.h>

template <typename _CharT, typename _Traits = std::char_traits<_CharT>,
	  typename _Alloc = std::allocator<_CharT> >
struct rope;

template <typename _CharT, typename _Traits, typename _Alloc>
struct rope
{
protected:
	typedef rope<_CharT, _Traits, _Alloc>         rope_type;
public:
	typedef _Traits                               traits_type;
	typedef typename _Traits::char_type           value_type;
	typedef _Alloc                                allocator_type;
	typedef typename _Alloc::size_type            size_type;
	typedef typename _Alloc::difference_type      difference_type;
	struct                                        reference;
	struct                                        pointer;
	struct                                        const_iterator;
	struct                                        iterator;
	typedef std::reverse_iterator<iterator>       reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	static size_type const npos;

protected:
	/* Useful named constants */
	enum
	{
		/// We allocate leaf data in increments of
		/// 1 << _S_alloc_granularity_shift.
		_S_alloc_granularity_shift = 3,

		/// Iterators will store _S_path_cache_len rope node references.
		_S_path_cache_len = 5,

		/// Iterators will cache _S_iterator_buf_len characters from
		/// non-leaf rope nodes.
		_S_iterator_buf_len = 16,

		/// For strings shorter than _S_max_copy, we copy to
		/// concatenate.
		_S_max_copy = 23,

		/// When dumping internal structure, string printouts are
		/// cut to _S_max_printout_len characters.
		_S_max_printout_len = 40,

		/// Maximal rope tree depth.
		_S_max_rope_depth = 45,

		/// For substrings longer than _S_lazy_threshold, we create
		/// substring nodes.
		_S_lazy_threshold = 128
	};

	/* Tag for simplified dynamic-like rope component casts. */
	enum class _rope_tag : uint8_t
	{
		_S_null = 0,
		_S_leaf,
		_S_concat,
		_S_substr,
		_S_func,
		_S_last_tag
	};

	static unsigned long const _S_min_len[_S_max_rope_depth + 1];

	struct _rope_rep;
	struct _rope_leaf;
	struct _rope_concat;
	struct _rope_substr;
	struct _rope_func;

	typedef counted_ptr<_rope_rep> rope_rep_ptr;
	typedef counted_ptr<_rope_leaf> rope_leaf_ptr;
	typedef counted_ptr<_rope_concat> rope_concat_ptr;
	typedef counted_ptr<_rope_substr> rope_substr_ptr;
	typedef counted_ptr<_rope_func> rope_func_ptr;

	/*
	 * Piece-wise application of functions to rope nodes may require
	 * access to allocator, which is stored externally to the actual rope
	 * node. This effectively precludes the use of virtual dispatch,
	 * as reference to the enclosing counted_ptr may be required.
	 */
	struct _rope_rep_ops
	{
		bool (*apply)(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		rope_rep_ptr (*substring)(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	static _rope_rep_ops const _S_rep_ops[_rope_tag::_S_last_tag];

	/**
	 * @brief _rope_rep implementation cast.
	 *
	 * This is equivalent to dynamic_pointer_cast in functionality, but only
	 * applicable to _rope_rep derived types, for some added performance
	 * (compared to generic dynamic_cast<>).
	 */
	template <typename _Tp1, typename _Tp2>
	static counted_ptr<_Tp1> _S_rep_cast(counted_ptr<_Tp2> const &__p)
	{
		if ((_Tp1::_S_ref_tag == __p->_M_tag)
		    || (_Tp1::_S_ref_tag == _rope_tag::_S_null))
			return static_pointer_cast<_Tp1>(__p);
		else
			return counted_ptr<_Tp1>();
	}

	struct _rope_rep
	{
		static _rope_tag const _S_ref_tag = _rope_tag::_S_null;

		_rope_tag _M_tag;
		uint8_t   _M_depth;
		uint8_t   _M_is_balanced;
		size_type _M_size;

		static bool _S_apply(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			return false;
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		)
		{
			return rope_rep_ptr();
		}

	protected:
		_rope_rep(_rope_tag __tag, uint8_t __d, bool __b,
			  size_type __size)
		: _M_tag(__tag), _M_depth(__d), _M_is_balanced(__b ? 1 : 0),
		  _M_size(__size)
		{}
	};

	struct _rope_leaf : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_leaf;

		_CharT _M_data[];

		static size_type _S_rounded_up_size(size_type __n)
		{
			// Allow slop for in-place expansion.

			return ((__n >> _S_alloc_granularity_shift) + 1)
			       << _S_alloc_granularity_shift;
		}

		_rope_leaf(size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
		}

		_rope_leaf(size_type __n, _CharT __c)
		: _rope_rep(_S_ref_tag, 0, true, __n)
		{
			traits_type::assign(_M_data, __n, __c);
		}

		_rope_leaf(_CharT const *__s, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
			if (__len == 1)
				traits_type::assign(_M_data[0], *__s);
			else
				traits_type::copy(_M_data, __s, __len);
		}

		static rope_leaf_ptr _S_make(size_type __len,
					     _Alloc __a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__len
			);
		}

		static rope_leaf_ptr _S_make(size_type __n, _CharT __c,
					     _Alloc __a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__n)
				),
				__n, __c
			);
		}

		static rope_leaf_ptr _S_make(_CharT const *__s, size_type __len,
					     _Alloc __a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__s, __len
			);
		}

		static bool _S_apply(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			rope_leaf_ptr __l(static_pointer_cast<_rope_leaf>(__r));
			return __f(__l->_M_data + __begin, __end - __begin);
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	struct _rope_concat : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_left;
		rope_rep_ptr _M_right;

		_rope_concat(rope_rep_ptr const &__l, rope_rep_ptr const &__r)
		: _rope_rep(
			_S_ref_tag,
			std::max(__l->_M_depth, __r->_M_depth) + 1,
			false, __l->_M_size + __r->_M_size
		 ),
		 _M_left(__l), _M_right(__r)
		{}

		static rope_concat_ptr _S_make(rope_rep_ptr const &__l,
					       rope_rep_ptr const &__r,
					       _Alloc __a)
		{
			return allocate_counted<_rope_concat>(
				__a, __l, __r
			);
		}

		static rope_concat_ptr _S_make(rope_rep_ptr const &__l,
					       rope_rep_ptr const &__r)
		{
			return _S_make(__l, __r, *get_allocator<_Alloc>(__l));
		}

		static bool _S_apply(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		static rope_rep_ptr _S_substring(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	struct _rope_substr : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_base;
		size_type    _M_start;

		_rope_substr(rope_rep_ptr const &__base, size_type __start,
			     size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_base(__base),
		  _M_start(__start)
		{}

		static rope_substr_ptr _S_make(
			rope_rep_ptr const &__base, size_type __start,
			size_type __len, _Alloc __a)
		{
			return allocate_counted<_rope_substr>(
				__a, __base, __start, __len
			);
		}

		static bool _S_apply(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			rope_substr_ptr __s(
				static_pointer_cast<_rope_substr>(__r)
			);
			return rope_type::_S_apply(
				__s->_M_base, __f, __begin + __s->_M_start,
				std::min(__s->_M_size, __end)
			);
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	struct _rope_func : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_func;

		std::function<void (size_type, size_type, _CharT *)> _M_fn;

		_rope_func(decltype(_M_fn) __f, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_fn(__f)
		{}

		/* _M_fn will be evaluated into a temporary leaf node,
		 * before application of __f.
		 */
		static bool _S_apply(
			rope_rep_ptr const &__r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			size_type __len(__end - __begin);
			rope_leaf_ptr __l(
				_rope_leaf::_S_make(
					__len, *get_allocator<_Alloc>(__r)
				)
			);

			static_pointer_cast<_rope_func>(__r)->_M_fn(
				__begin, __len, __l->_M_data
			);

			return __f(__l->_M_data, __len);
		}


		static rope_rep_ptr _S_substring(
			rope_rep_ptr const &__r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	struct _iterator_base
	{
		/// Iterator value.
		size_type    _M_current_pos;
		/// The whole referenced rope.
		rope_rep_ptr _M_root;
		/// Starting position for the current leaf
		size_type    _M_leaf_pos;

		/// _M_path_end contains the bottom section of the path
		/// from the root to the current leaf, representing partial
		/// path cache. The path is truncated to keep iterators copying
		/// penalty to the possible minimum.
		rope_rep_ptr _M_path_end[_S_path_cache_len];

		/// Last valid position in _M_path_end.
		/// _M_path_end[0] ... _M_path_end[_M_path_index-1]
		/// point to concatenation nodes.
		int _M_path_index;

		/// (_M_path_directions >> __i) & 1 is 1
		/// iff we got from _M_path_end[_M_path_index - __i - 1]
		/// to _M_path_end[_M_path_index - __i] by going to the
		/// __right.
		unsigned int _M_path_directions;

		/// Buffer possibly containing current char.
		value_type const *_M_buf_begin;

		/// One past last valid value in buffer.
		value_type const *_M_buf_end;

		/// Pointer to current char in buffer.
		/// Iff _M_buf_cur != 0 buffer is valid.
		value_type const *_M_buf_cur;

		/// Short buffer for surrounding values.
		/// This is useful primarily for function nodes.  We put the
		/// buffer here to avoid locking in the multithreaded case.
		/// The cached path is generally assumed to be valid only if
		/// the buffer is valid.
		_CharT _M_tmp_buf[_S_iterator_buf_len];

		/**
		 * @brief Set buffer contents given path cache.
		 */
		static void _S_setbuf(_iterator_base &__iter);

		/**
		 * @brief Set buffer contents and path cache.
		 */
		static void _S_setcache(_iterator_base &__iter);

		/**
		 * @brief Set buffer contents and path cache.
		 *
		 * Assumes path cache is valid for previous position.
		 */
		static void _S_setcache_for_incr(_iterator_base &__iter);

		void _M_incr(size_type __n);
		void _M_decr(size_type __n);

		size_type index() const
		{
			return _M_current_pos;
		}

		_iterator_base()
		{}

		_iterator_base(rope_rep_ptr const &__root, size_type __pos)
		: _M_current_pos(__pos), _M_root(__root), _M_buf_cur(0)
		{}

		_iterator_base(_iterator_base const &__iter)
		{
			if (__iter._M_buf_cur)
				*this = __iter;
			else {
				_M_current_pos = __iter._M_current_pos;
				_M_root = __iter._M_root;
				_M_buf_cur = 0;
			}
		}
	};

	/**
	 * @brief Definition of the balanced sub-tree.
	 */
	static bool _S_is_balanced(rope_rep_ptr const &__r)
	{
		return (__r->_M_size >= _S_min_len[__r->_M_depth]);
	}

	static rope_rep_ptr _S_concat_and_set_balanced(rope_rep_ptr const &__l,
						       rope_rep_ptr const &__r)
	{
		rope_rep_ptr __result(_S_concat(__l, __r));

		if (_S_is_balanced(__result))
			__result->_M_is_balanced = true;

		return __result;
	}

	/**
	 * @brief Add __r to forest, assuming __r is already balanced.
	 */
	static void _S_add_leaf_to_forest(rope_rep_ptr const &__r,
					  rope_rep_ptr *__forest);

	/**
	 * @brief Add all unbalanced subtrees to the forest of balanced trees.
	 *
	 * Used only by _S_balance.
	 */
	static void _S_add_to_forest(rope_rep_ptr const &__r,
				     rope_rep_ptr *__forest);

	/**
	 * @brief The basic rebalancing operation.
	 *
	 * Logically copies the rope. The result is within height 2 of
	 * balanced by the above definition.
	 */
	static rope_rep_ptr _S_balance(rope_rep_ptr const &__r);

	/**
	 * @brief General concatenation on rope_rep.
	 */
	static rope_rep_ptr _S_concat(rope_rep_ptr const &__l,
				      rope_rep_ptr const &__r);

	/**
	 * @brief Concatenation of nonempty strings.
	 *
	 * Always builds a concatenation node.
	 * Rebalances if the result is too deep.
	 */
	static rope_rep_ptr _S_tree_concat(rope_rep_ptr const &__l,
					   rope_rep_ptr const &__r);

	/**
	 * @brief Concatenate by copying leaf.
	 */
	template <typename _InputIterator>
	static rope_leaf_ptr _S_leaf_concat_char_iter(rope_leaf_ptr const &__r,
						      _InputIterator __iter,
						      size_type __len);

	/**
	 * @brief Concatenate rope and input iterator, copying __s.
	 */
	template <typename _InputIterator>
	static rope_rep_ptr _S_concat_char_iter(rope_rep_ptr const &__r,
						_InputIterator __iter,
						size_type __len);

	/**
	 * @brief Copy substring of __r to the _CharT array.
	 *
	 * @return Pointer to the end of the array.
	 */
	static _CharT *_S_flatten(rope_rep_ptr const &__r, size_type __begin,
				  size_type __len, _CharT *__s);

	/**
	 * @brief Copy __r to the _CharT array.
	 *
	 * @return Pointer to the end of the array (__s + __r->_M_size).
	 */
	static _CharT *_S_flatten(rope_rep_ptr const &__r, _CharT *__s)
	{
		return _S_flatten(__r, 0, __r->_M_size, __s);
	}

	/**
	 * @brief Retrieve a character at the indicated position.
	 */
	static _CharT _S_fetch(rope_rep_ptr const &__r, size_type __pos);

	/**
	 * @brief Construct rope tree representing a substring of __r.
	 *
	 * Rope will be recursively traversed because of rope_concat_ptr and
	 * rope_substr_ptr semantics.
	 */
	static rope_rep_ptr _S_substring(
		rope_rep_ptr const &__r, size_type __begin, size_type __end
	)
	{
		if (!__r)
			return __r;

		size_type __len(__r->_M_size);
		size_type __adj_end;

		if (__end >= __len) {
			if (0 == __begin)
				return __r;
			else
				__adj_end = __len;
		} else
			__adj_end = __end;

		return _S_rep_ops[static_cast<size_t>(__r->_M_tag)]
		       .substring(__r, __begin, __end, __adj_end);

	}

	/**
	 * @brief Apply __f to generic rope piece.
	 *
	 * Rope will be recursively traversed because of rope_concat_ptr and
	 * rope_substr_ptr semantics.
	 */
	static bool _S_apply(
		rope_rep_ptr const &__r,
		std::function<bool (_CharT const *, size_type)> __f,
		size_type __begin, size_type __end
	)
	{
		if (__r)
			return _S_rep_ops[static_cast<size_t>(__r->_M_tag)]
			       .apply(__r, __f, __begin, __end);
		else
			return true;
	}

	/**
	 * @brief Replace a value range within __old with contents of __r.
	 */
	static rope_rep_ptr _S_replace(rope_rep_ptr const &__old, size_type __b,
				       size_type __e, rope_rep_ptr const &__r)
	{
		if (!__old)
			return __r;

		rope_rep_ptr __left(_S_substring(__old, 0, __b));
		rope_rep_ptr __right(
			_S_substring(__old, __e, __old->_M_size)
		);

		if (!__r)
			return _S_concat(__left, __right);
		else
			return _S_concat(_S_concat(__left, __r), __right);
	}

	/**
	 * @brief Slightly faster rope subtree 3 way compare.
	 *
	 * This function will bypass the use of rope iterators if one or both
	 * subtrees are single leafs.
	 */
	int _S_compare(rope_rep_ptr const &__left, rope_rep_ptr const &__right);

	/**
	 * @brief Dump internal rope structure to the supplied ostream.
	 */
	static std::basic_ostream<_CharT, _Traits> &_S_dump(
		rope_rep_ptr const &__r,
		std::basic_ostream<_CharT, _Traits> &__os,
		int __indent = 0
	);

	std::tuple<rope_rep_ptr, allocator_type> _M_treeplus;

private:
	rope(rope_rep_ptr const &__t, _Alloc __a = _Alloc())
	: _M_treeplus(__t, __a)
	{}
/*
	rope(rope_rep_ptr const &__t, _Alloc const &__a)
	: _M_treeplus(__t, __a)
	{}
*/
public:
	struct reference
	{
		reference(rope_type &__r, size_type __pos)
		: _M_root(__r), _M_pos(__pos), _M_current_valid(false)
		{}

		reference(reference const &__ref)
		: _M_root(__ref._M_root), _M_pos(__ref._M_pos),
		  _M_current_valid(false), _M_current(__ref._M_current)
		{}

		reference(rope_type &__r, size_type __pos, _CharT __c)
		: _M_root(__r), _M_pos(__pos), _M_current_valid(true),
		  _M_current(__c)
		{}

		operator _CharT () const
		{
			if (_M_current_valid)
				return _M_current;
			else
				return rope_type::_S_fetch(
					std::get<0>(_M_root._M_treeplus),
					_M_pos
				);
		}

		reference &operator=(_CharT __c)
		{
			rope_rep_ptr __old(std::get<0>(_M_root._M_treeplus));

			rope_rep_ptr __left(
				rope_type::_S_substring(__old, 0, _M_pos)
			);
			rope_rep_ptr __right(
				rope_type::_S_substring(__old, _M_pos + 1,
							__old->_M_size)
			);

			std::get<0>(_M_root._M_treeplus) = rope_type::_S_concat(
				rope_type::_S_concat_char_iter(__left, &__c, 1),
				__right
			);

			return *this;
		}

		pointer operator&() const
		{
			return pointer(*this);
		}

		reference &operator=(reference const &__c)
		{
			return operator=(_CharT(__c));
		}

	private:
		friend struct pointer;

		rope_type   &_M_root;
		size_type    _M_pos;
		bool         _M_current_valid;
		_CharT       _M_current;
	};

	struct pointer
	{
		pointer(reference const &__ref)
		: _M_root(&__ref._M_root), _M_pos(__ref._M_pos)
		{}

		pointer(pointer const &__ptr)
		: _M_root(&__ptr._M_root), _M_pos(__ptr._M_pos)
		{}

		pointer()
		: _M_root(0), _M_pos(0)
		{}

		pointer &operator=(pointer const &__ptr)
		{
			_M_root = __ptr._M_root;
			_M_pos = __ptr._M_pos;
			return *this;
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend bool operator==(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::pointer const &__x,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::pointer const &__y
		)
		{
			return (__x._M_pos == __y._M_pos)
				&& (__x._M_root == __y._M_root);
		}

		reference operator*() const
		{
			return reference(_M_root, _M_pos);
		}

	private:
		rope_type   *_M_root;
		size_type    _M_pos;
	};

	struct const_iterator : public _iterator_base
	{
		typedef std::random_access_iterator_tag iterator_category;
		typedef rope_type::value_type           value_type;
		typedef _CharT                          reference;
		typedef _CharT const *                  pointer;
		typedef rope_type::size_type            size_type;
		typedef rope_type::difference_type      difference_type;

		const_iterator()
		{};

		const_iterator(const_iterator const &__iter)
		: _iterator_base(__iter)
		{}

		const_iterator(iterator const &__iter)
		: _iterator_base(__iter)
		{}

		const_iterator(rope_type const &__r, size_type __pos)
		: _iterator_base(std::get<0>(__r._M_treeplus), __pos)
		{}

		const_iterator &operator=(const_iterator const &__iter)
		{
			if (__iter._M_buf_cur)
				_iterator_base::operator=(__iter);
			else
			{
				this->_M_current_pos = __iter._M_current_pos;
				this->_M_root = __iter._M_root;
				this->_M_buf_cur = 0;
			}

			return(*this);
		}

		reference operator*()
		{
			if (!this->_M_buf_cur)
				this->_S_setcache(*this);

			return *this->_M_buf_cur;
		}

		reference operator*() const
		{
			return *const_cast<const_iterator &>(*this);
		}

		const_iterator &operator++()
		{
			_CharT const *__next(this->_M_buf_cur + 1);

			if (this->_M_buf_cur && __next < this->_M_buf_end) {
				this->_M_buf_cur = __next;
				++(this->_M_cur_pos);
			} else
				this->_M_incr(1);

			return *this;
		}

		const_iterator &operator+=(difference_type __n)
		{
			if (__n >= 0)
				_M_incr(__n);
			else
				_M_decr(-__n);

			return *this;
		}

		const_iterator &operator--()
		{
			this->_M_decr(1);
			return *this;
		}

		const_iterator &operator-=(difference_type __n)
		{
			if (__n >= 0)
				this->_M_decr(__n);
			else
				this->_M_incr(-__n);

			return *this;
		}

		const_iterator operator++(int)
		{
			size_type __old_pos(this->_M_current_pos);
			this->_M_incr(1);
			return const_iterator(this->_M_root, __old_pos);
		}

		const_iterator operator--(int)
		{
			size_type __old_pos(this->_M_current_pos);
			this->_M_decr(1);
			return const_iterator(this->_M_root, __old_pos);
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend typename rope<_CharT2, _Traits2, _Alloc2>::const_iterator
		operator-(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__iter,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::difference_type __n
		)
		{
			return const_iterator(
				__iter._M_root, __iter._M_current_pos - __n
			);
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend typename rope<_CharT2, _Traits2, _Alloc2>::const_iterator
		operator+(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__iter,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::difference_type __n
		)
		{
			return const_iterator(
				__iter._M_root, __iter._M_current_pos + __n
			);
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend typename rope<_CharT2, _Traits2, _Alloc2>::const_iterator
		operator+(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::difference_type __n,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__iter
		)
		{
			return const_iterator(
				__iter._M_root, __iter._M_current_pos + __n
			);
		}

		reference operator[](size_type __n)
		{
			return rope_type::_S_fetch(
				this->_M_root, this->_M_current_pos + __n
			);
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend bool operator==(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__x,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__y
		)
		{
			return (__x._M_current_pos == __y._M_current_pos)
			       && (__x._M_root == __y._M_root);
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend bool operator<(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__x,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__y
		)
		{
			return __x._M_current_pos < __y._M_current_pos;
		}

		template<typename _CharT2, typename _Traits2, typename _Alloc2>
		friend typename rope<_CharT2, _Traits2, _Alloc2>
		::difference_type operator-(
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__x,
			typename rope<_CharT2, _Traits2, _Alloc2>
			::const_iterator const &__y
		)
		{
			return static_cast<difference_type>(__x._M_current_pos)
			       - static_cast<difference_type>(
					__y._M_current_pos
				);
		}

	protected:
		const_iterator(rope_rep_ptr const &__root, size_type __pos)
		: _iterator_base(__root, __pos)
		{}
	};

	struct iterator : public _iterator_base
	{
		typedef std::random_access_iterator_tag iterator_category;
		typedef rope_type::value_type           value_type;
		typedef rope_type::reference            reference;
		typedef rope_type::pointer              pointer;
		typedef rope_type::size_type            size_type;
		typedef rope_type::difference_type      difference_type;
	};

	bool empty() const
	{
		return !(_M_treeplus._M_v);
	}

	int compare(rope const &__r) const
	{
		return _S_compare(std::get<0>(_M_treeplus),
				  std::get<0>(__r._M_treeplus));
	}

	rope(_CharT const *__s, _Alloc __a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{
		if (__s && traits_type::length(__s)) {
			rope_leaf_ptr __l(
				_rope_leaf::_S_make(
					__s, traits_type::length(__s), __a
				)
			);
			std::get<0>(_M_treeplus) = __l;
		}
	}

	rope(_CharT const *__s, size_type __len, _Alloc __a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{
		if (__s && __len) {
			rope_leaf_ptr __l(_rope_leaf::_S_make(__s, __len, __a));
			std::get<0>(_M_treeplus) = __l;
		}
	}

	template <typename _InputIterator>
	rope(_InputIterator __b, _InputIterator __e, _Alloc __a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{
		size_type __len(__e - __b);

		if (__len) {
			rope_leaf_ptr __l(_rope_leaf::_S_make(__len, __a));
			std::copy(__b, __e, __l->_M_data);
			std::get<0>(_M_treeplus) = __l;
		}
	}

	rope(const_iterator const &__b, const_iterator const &__e,
	     _Alloc __a = _Alloc())
	: _M_treeplus(_S_substring(__b._M_root, __b._M_current_pos,
				   __e._M_current_pos), __a)
	{}

	rope(iterator const &__b, iterator const &__e,
	     _Alloc __a = _Alloc())
	: _M_treeplus(_S_substring(__b._M_root, __b._M_current_pos,
				   __e._M_current_pos), __a)
	{}

	rope(_CharT __c, _Alloc __a = _Alloc())
	: _M_treeplus(_rope_leaf::_S_make(1, __c, __a), __a)
	{}

	rope(size_type __n, _CharT __c, _Alloc __a = _Alloc());

	rope(_Alloc __a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{}

	rope(std::function<void (size_type, size_type, _CharT *)> __fn,
	     size_type __len, _Alloc __a = _Alloc())
	: _M_treeplus(_rope_func::_S_make(__fn, __len, __a), __a)
	{}

	rope(rope const &__r)
	: _M_treeplus(__r._M_treeplus)
	{}

	rope(rope &&__r)
	: _M_treeplus(__r._M_treeplus)
	{
		std::get<0>(__r._M_treeplus).reset();
	}

	~rope()
	{}

	rope &operator=(rope const &__r)
	{
		std::get<0>(_M_treeplus) = std::get<0>(__r._M_treeplus);

		return *this;
	}

	rope &operator=(rope &&__r)
	{
		std::get<0>(_M_treeplus) = std::get<0>(__r._M_treeplus);
		std::get<0>(__r._M_treeplus).reset();

		return *this;
	}

	void clear()
	{
		std::get<0>(_M_treeplus).reset();
	}

	void push_back(_CharT __c)
	{
		append(__c);
	}

	void pop_back()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus)
		= _S_substring(__old, 0, __old->_M_size - 1);
	}

	_CharT back() const
	{
		rope_rep_ptr __r(std::get<0>(_M_treeplus));

		return _S_fetch(__r, __r->_M_size - 1);
	}

	void push_front(_CharT __c)
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));
		rope_leaf_ptr __l(
			_rope_leaf::_S_make(&__c, 1, std::get<1>(_M_treeplus))
		);

		std::get<0>(_M_treeplus) = _S_concat(__l, __old);
	}

	void pop_front()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus)
		= _S_substring(__old, 1, __old->_M_size);
	}

	_CharT front() const
	{
		return _S_fetch(std::get<0>(_M_treeplus), 0);
	}

	void balance()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus) = _S_balance(__old);
	}

	void copy(_CharT *__s) const
	{
		_S_flatten(std::get<0>(_M_treeplus), __s);
	}

	size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const
	{
		size_type __size(size());
		size_type __len(__pos + __n > __size ? __size - __pos : __n);

		_S_flatten(std::get<0>(_M_treeplus), __pos, __len, __s);
		return __len;
	}

	class _rope_dumper
	{
		friend class rope;
		rope_rep_ptr _M_r;

		_rope_dumper(rope_rep_ptr const &__r)
		: _M_r(__r)
		{}

		std::basic_ostream<_CharT, _Traits> &_M_dump(
			std::basic_ostream<_CharT, _Traits> &__os
		) const
		{
			return rope_type::_S_dump(_M_r, __os);
		}

		friend std::basic_ostream<_CharT, _Traits> &operator<<(
			std::basic_ostream<_CharT, _Traits> &__os,
			_rope_dumper const &__d
		)
		{
			return __d._M_dump(__os);
		}
	};

	/**
	 * @brief Expose internal rope structure.
	 *
	 * Useful primarily for debugging.
	 * @return Proxy object which can be printed to ostream interface.
	 */
	_rope_dumper dump()
	{
		 return _rope_dumper(std::get<0>(_M_treeplus));
	}

	std::basic_string<_CharT, _Traits, _Alloc> str() const
	{
		std::basic_string<_CharT, _Traits, _Alloc> __s;
		__s.reserve(size());
		copy(__s.data());
		return __s;
	}

	void flatten()
	{
		rope_leaf_ptr __l(
			_S_rep_cast<_rope_leaf>(std::get<0>(_M_treeplus))
		);

		if (!__l && std::get<0>(_M_treeplus)) {
			__l = _rope_leaf::_S_make(size(),
						  std::get<1>(_M_treeplus));
			copy(__l->_M_data);
			std::get<0>(_M_treeplus) = __l;
		}
	}

	_CharT operator[](size_type __pos) const
	{
		return _S_fetch(std::get<0>(_M_treeplus), __pos);
	}

	const_iterator begin() const
	{
		return const_iterator(std::get<0>(_M_treeplus), 0);
	}

	const_iterator const_begin() const
	{
		return const_iterator(std::get<0>(_M_treeplus), 0);
	}

	const_iterator end() const
	{
		return const_iterator(std::get<0>(_M_treeplus), size());
	}

	const_iterator const_end() const
	{
		return const_iterator(std::get<0>(_M_treeplus), size());
	}

	size_type size() const
	{
		if (std::get<0>(_M_treeplus))
			return std::get<0>(_M_treeplus)->_M_size;
		else
			return 0;
	}

	size_type length() const
	{
		return size();
	}

	size_type capacity() const
	{
		// Any modification to the rope will result in memory
		// allocation.
		return size();
	}

	size_type max_size() const
	{
		//  Guarantees that the result can be sufficiently
		//  balanced.  Longer ropes will probably still work,
		//  but it's harder to make guarantees.
		return _S_min_len[_S_max_rope_depth - 1] - 1;
	}

	const_reverse_iterator rbegin() const
	{
		return const_reverse_iterator(end());
	}

	const_reverse_iterator const_rbegin() const
	{
		return const_reverse_iterator(end());
	}

	const_reverse_iterator rend() const
	{
		return const_reverse_iterator(begin());
	}

	const_reverse_iterator const_rend() const
	{
		return const_reverse_iterator(begin());
	}

	rope &operator+=(rope const &__r)
	{
		return append(__r);
	}

	rope &operator+=(_CharT const *__s)
	{
		return append(__s);
	}

	rope &operator+=(_CharT __c)
	{
		return append(__c);
	}

	template <typename _InputIterator>
	rope &append(_InputIterator __iter, size_type __len)
	{
		if (std::get<0>(_M_treeplus))
			std::get<0>(_M_treeplus) = _S_concat_char_iter(
				std::get<0>(_M_treeplus), __iter, __len
			);
		else
			std::get<0>(_M_treeplus) = _rope_leaf::_S_make(
				__iter, __len, std::get<1>(_M_treeplus)
			);

		return *this;
	}

	rope &append(_CharT const *__s)
	{
		return append(__s, traits_type::length(__s));
	}

	template <typename _InputIterator>
	rope &append(_InputIterator __b, _InputIterator __e)
	{
		return append(__b, __e - __b);
	}

	rope &append(const_iterator __b, const_iterator __e)
	{
		std::get<0>(_M_treeplus) = _S_concat(
			std::get<0>(_M_treeplus),
			_S_substring(
				__b._M_root,
				__b._M_current_pos,
				__e._M_current_pos
			)
		);

		return *this;
	}

	rope &append(_CharT __c)
	{
		return append(&__c, 1);
	}

	rope &append(rope const &__r)
	{
		std::get<0>(_M_treeplus) = _S_concat(
			std::get<0>(_M_treeplus),
			std::get<0>(__r._M_treeplus)
		);
		return *this;
	}

	rope &append(size_type __n, _CharT __c)
	{
		return append(rope_type(__n, __c, std::get<1>(_M_treeplus)));
	}

	void swap(rope &__r)
	{
		_M_treeplus.swap(__r._M_treeplus);
	}

	void insert(size_type __p, rope const &__r)
	{
		std::get<0>(_M_treeplus) = _S_replace(
			std::get<0>(_M_treeplus), __p, __p,
			std::get<0>(__r._M_treeplus)
		);
	}

	void insert(size_type __p, size_type __n, _CharT __c)
	{
		rope_type __r(__n, __c, std::get<1>(_M_treeplus));
		insert(__p, __r);
	}

	template <typename _InputIterator>
	void insert(size_type __p, _InputIterator __iter, size_type __len)
	{
		rope_rep_ptr __left(std::get<0>(_M_treeplus), 0, __p);
		rope_rep_ptr __right(std::get<0>(_M_treeplus), __p, size());

		std::get<0>(_M_treeplus) = _S_concat(
			_S_concat_char_iter(__left, __iter, __len),
			__right
		);
	}

	void insert(size_type __p, _CharT const *__s)
	{
		insert(__p, __s, traits_type::length(__s));
	}

	void insert(size_type __p, _CharT __c)
	{
		insert(__p, &__c, 1);
	}

	template <typename _InputIterator>
	void insert(size_type __p, _InputIterator __b, _InputIterator __e)
	{
		rope_type __r(__b, __e, std::get<1>(_M_treeplus));
		insert(__p, __r);
	}

	void insert(size_type __p, const_iterator const &__b,
		    const_iterator const &__e)
	{
		rope_type __r(__b, __e, std::get<1>(_M_treeplus));
		insert(__p, __r);
	}

	void insert(size_type __p, iterator const &__b, iterator const &__e)
	{
		rope_type __r(__b, __e, std::get<1>(_M_treeplus));
		insert(__p, __r);
	}

	void replace(size_type __p, size_type __n, rope const &__r)
	{
		std::get<0>(_M_treeplus) = _S_replace(
			std::get<0>(_M_treeplus), __p, __p + __n,
			std::get<0>(__r._M_treeplus)
		);
	}

	template <typename _InputIterator>
	void replace(size_type __p, size_type __n, _InputIterator __iter,
		     size_type __len)
	{
		rope_type __r(__iter, __len, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	void replace(size_type __p, size_type __n, _CharT __c)
	{
		rope_type __r(__c, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	void replace(size_type __p, size_type __n, _CharT const *__s)
	{
		rope_type __r(__s, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	template <typename _InputIterator>
	void replace(size_type __p, size_type __n, _InputIterator __b,
		     _InputIterator __e)
	{
		rope_type __r(__b, __e, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	void replace(size_type __p, size_type __n, const_iterator const &__b,
		     const_iterator const &__e)
	{
		rope_type __r(__b, __e, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	void replace(size_type __p, size_type __n, iterator const &__b,
		     iterator const &__e)
	{
		rope_type __r(__b, __e, std::get<1>(__r._M_treeplus));
		replace(__p, __n, __r);
	}

	void replace(size_type __p, _CharT __c)
	{
		iterator __i(this, __p);
		*__i = __c;
	}

	void replace(size_type __p, rope const &__r)
	{
		replace(__p, 1, __r);
	}

	template <typename _InputIterator>
	void replace(size_type __p, _InputIterator __iter, size_type __len)
	{
		replace(__p, 1, __iter, __len);
	}

	void replace(size_type __p, _CharT const *__s)
	{
		replace(__p, 1, __s);
	}

	template <typename _InputIterator>
	void replace(size_type __p, _InputIterator __b, _InputIterator __e)
	{
		replace(__p, 1, __b, __e);
	}

	void replace(size_type __p, const_iterator const &__b,
		     const_iterator const &__e)
	{
		replace(__p, 1, __b, __e);
	}

	void replace(size_type __p, iterator const &__b, iterator const &__e)
	{
		replace(__p, 1, __b, __e);
	}

	void erase(size_type __p, size_type __n)
	{
		std::get<0>(_M_treeplus) = _S_replace(
			std::get<0>(_M_treeplus), __p, __p + __n,
			rope_rep_ptr()
		);
	}

	void erase(size_type __p)
	{
		erase(__p, __p + 1);
	}

	iterator insert(iterator const &__p, const rope& __r)
	{
		insert(__p.index(), __r);
		return __p;
	}

	iterator insert(iterator const &__p, size_type __n, _CharT __c)
	{
		insert(__p.index(), __n, __c);
		return __p;
	}

	iterator insert(iterator const &__p, _CharT __c)
	{
		insert(__p.index(), __c);
		return __p;
	}

	iterator insert(iterator const &__p, _CharT const *__s)
	{
		insert(__p.index(), __s);
		return __p;
	}

	template <typename _InputIterator>
	iterator insert(iterator const &__p, _InputIterator __i,
			size_type __len)
	{
		insert(__p.index(), __i, __len);
		return __p;
	}

	template <typename _InputIterator>
	iterator insert(iterator const &__p, _InputIterator __b,
			_InputIterator __e)
	{
		insert(__p.index(), __b, __e);
		return __p;
	}

	iterator insert(iterator const &__p, const_iterator const &__b,
			const_iterator const &__e)
	{
		insert(__p.index(), __b, __e);
		return __p;
	}

	iterator insert(iterator const &__p, iterator const &__b,
			iterator const &__e)
	{
		insert(__p.index(), __b, __e);
		return __p;
	}

	void replace(iterator const &__b, iterator const &__e, rope const &__r)
	{
		replace(__b.index(), __e.index() - __b.index(), __r);
	}

	void replace(iterator const &__b, iterator const &__e, _CharT __c)
	{
		replace(__b.index(), __e.index() - __b.index(), __c);
	}

	void replace(iterator const &__b, iterator const &__e,
		     _CharT const *__s)
	{
		replace(__b.index(), __e.index() - __b.index(), __s);
	}

	template <typename _InputIterator>
	void replace(iterator const &__b, iterator const &__e,
		     _InputIterator __i, size_type __len)
	{
		replace(__b.index(), __e.index() - __b.index(), __i, __len);
	}

	template <typename _InputIterator>
	void replace(iterator const &__b, iterator const &__e,
		     _InputIterator __i_b, _InputIterator __i_e)
	{
		replace(__b.index(), __e.index() - __b.index(), __i_b, __i_e);
	}

	void replace(iterator const &__b, iterator const &__e,
		     const_iterator const &__i_b, const_iterator const &__i_e)
	{
		replace(__b.index(), __e.index() - __b.index(), __i_b, __i_e);
	}

	void replace(iterator const &__b, iterator const &__e,
		     iterator const &__i_b, iterator const &__i_e)
	{
		replace(__b.index(), __e.index() - __b.index(), __i_b, __i_e);
	}

	void replace(iterator const &__p, rope const &__r)
	{
		replace(__p.index(), __r);
	}

	void replace(iterator const &__p, _CharT __c)
	{
		replace(__p.index(), __c);
	}

	void replace(iterator const &__p, _CharT const *__s)
	{
		replace(__p.index(), __s);
	}

	template <typename _InputIterator>
	void replace(iterator const &__p, _InputIterator __i, size_type __len)
	{
		replace(__p.index(), __i, __len);
	}

	template <typename _InputIterator>
	void replace(iterator const &__p, _InputIterator __b,
		     _InputIterator __e)
	{
		replace(__p.index(), __b, __e);
	}

	void replace(iterator const &__p, const_iterator __b,
		     const_iterator __e)
	{
		replace(__p.index(), __b, __e);
	}

	void replace(iterator const &__p, iterator __b, iterator __e)
	{
		replace(__p.index(), __b, __e);
	}

	iterator erase(iterator const &__b, iterator const &__e)
	{
		size_type __b_index(__b.index());
		erase(__b_index, __e.index() - __b_index);
		return iterator(this, __b_index);
	}

	iterator erase(iterator const &__p)
	{
		size_type __p_index(__p.index());
		erase(__p_index, 1);
		return iterator(this, __p_index);
	}

	rope substr(size_type __pos, size_type __len = 1) const
	{
		return rope_type(
			_S_substring(
				std::get<0>(_M_treeplus), __pos,
				__pos + __len
			),
			std::get<1>(_M_treeplus)
		);
	}

	rope substr(iterator const &__b, iterator const &__e) const
	{
		return rope_type(
			_S_substring(
				std::get<0>(_M_treeplus), __b.index(),
				__e.index()
			),
			std::get<1>(_M_treeplus)
		);
	}

	rope substr(iterator const &__p) const
	{
		size_type __p_index(__p.index());

		return rope_type(
			_S_substring(
				std::get<0>(_M_treeplus), __p_index,
				__p_index + 1
			),
			std::get<1>(_M_treeplus)
		);
	}

	rope substr(const_iterator const &__b, const_iterator const &__e) const
	{
		return rope_type(
			_S_substring(
				std::get<0>(_M_treeplus), __b.index(),
				__e.index()
			),
			std::get<1>(_M_treeplus)
		);
	}

	rope substr(const_iterator const &__p) const
	{
		size_type __p_index(__p.index());

		return rope_type(
			_S_substring(
				std::get<0>(_M_treeplus), __p_index,
				__p_index + 1
			),
			std::get<1>(_M_treeplus)
		);
	}

	size_type find(_CharT __c, size_type __pos = 0) const;

	size_type find(_CharT const *__s, size_type __pos = 0) const;

	iterator mutable_begin()
	{
		return(iterator(this, 0));
	}

	iterator mutable_end()
	{
		return(iterator(this, size()));
	}

	reverse_iterator mutable_rbegin()
	{
		return reverse_iterator(mutable_end());
	}

	reverse_iterator mutable_rend()
	{
		return reverse_iterator(mutable_begin());
	}

	reference mutable_reference_at(size_type __pos)
	{
		return reference(this, __pos);
	}

	reference operator[] (size_type __pos)
	{
		return reference(this, __pos);
	}

	iterator end()
	{
		return mutable_end();
	}

	iterator begin()
	{
		return mutable_begin();
	}

	reverse_iterator rend()
	{
		return mutable_rend();
	}

	reverse_iterator rbegin()
	{
		return mutable_rbegin();
	}

	template <typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);

	template <typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 const *__s
	);

	template <typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 __c
	);

	template <typename _CharT2, typename _Traits2, typename _Alloc2>
	friend std::basic_ostream<_CharT2, _Traits2> &operator<<(
		std::basic_ostream<_CharT2, _Traits2> &__os,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);
};

template <typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	rope<_CharT, _Traits, _Alloc> const &__r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	return rope_type(
		rope_type::_S_concat(std::get<0>(__l._M_treeplus),
				     std::get<0>(__r._M_treeplus)),
		std::get<1>(__l._M_treeplus)
	);
}

template <typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT const *__s
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;
	typedef typename rope_type::size_type size_type;

	size_type __slen(rope_type::traits_type::length(__s));

	if (std::get<0>(__l._M_treeplus))
		return rope_type(
			__l._S_concat_char_iter(std::get<0>(__l._M_treeplus),
						__s, __slen),
			std::get<1>(__l._M_treeplus)
		);
	else
		return rope_type(__s, std::get<1>(__l._M_treeplus));
}

template <typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT __c
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	if (std::get<0>(__l._M_treeplus))
		return rope_type(
			__l._S_concat_char_iter(std::get<0>(__l._M_treeplus),
						&__c, 1),
			std::get<1>(__l._M_treeplus)
		);
	else
		return rope_type(1, __c, std::get<1>(__l._M_treeplus));
}

template <typename _CharT, typename _Traits, typename _Alloc>
std::basic_ostream<_CharT, _Traits> &operator<<(
	std::basic_ostream<_CharT, _Traits> &__os,
	rope<_CharT, _Traits, _Alloc> const &__r
);

typedef rope<char> crope;
typedef rope<wchar_t> wrope;

namespace std
{
template<>
struct hash<crope>
{
	size_t operator()(crope const &__str) const
	{
		size_t __size(__str.size());
		if (0 == __size)
			return 0;
		return 13 * __str[0] + 5 * __str[__size - 1] + __size;
	}
};

template<>
struct hash<wrope>
{
	size_t operator()(wrope const &__str) const
	{
		size_t __size(__str.size());
		if (0 == __size)
			return 0;
		return 13 * __str[0] + 5 * __str[__size - 1] + __size;
	}
};
} // namespace std

#include <rope.tcc>

#endif
