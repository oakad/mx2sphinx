// Reimplementation of SGI's rope class -*- C++ -*-

// Copyright (C) 2010 Alex Dubov <oakad@yahoo.com>
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3, or
// (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.


// Derived from original implementation
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
// Free Software Foundation, Inc.

// May contain parts
// Copyright (c) 1997
// Silicon Graphics Computer Systems, Inc.

// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear
// in supporting documentation.  Silicon Graphics makes no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied warranty.

#ifndef _EXT_ROPE
#define _EXT_ROPE 1

#include <iterator>
#include <counted_ptr.h>

template< typename _CharT, typename _Traits = std::char_traits<_CharT>,
	  typename _Alloc = std::allocator<_CharT> >
struct rope;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_iterator;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_const_iterator;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_char_ref_proxy;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_char_ptr_proxy;

template<typename _CharT, typename _Traits, typename _Alloc>
bool operator==(
	const _rope_char_ptr_proxy<_CharT, _Traits, _Alloc>& __x,
	const _rope_char_ptr_proxy<_CharT, _Traits, _Alloc>& __y
);
/*
template<typename _CharT, typename _Traits, typename _Alloc>
_rope_const_iterator<_CharT, _Traits, _Alloc> operator-(
	const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	ptrdiff_t __n
);

template<typename _CharT, typename _Traits, typename _Alloc>
_rope_const_iterator<_CharT, _Traits, _Alloc> operator+(
	const _rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_const_iterator<_CharT, _Traits, _Alloc>
    operator+(ptrdiff_t __n,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x);

  template<class _CharT, class _Alloc>
    bool
    operator==(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	       const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    bool
    operator<(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    ptrdiff_t
    operator-(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator-(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x, ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator+(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x, ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator+(ptrdiff_t __n, const _Rope_iterator<_CharT, _Traits, _Alloc>& __x);

  template<class _CharT, class _Alloc>
    bool
    operator==(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	       const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    bool
    operator<(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    ptrdiff_t
    operator-(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);




template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__left,
	_CharT const *__right
);

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__left,
	_CharT __right
);
*/

template<typename _CharT, typename _Traits, typename _Alloc>
struct rope
{
protected:
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

public:
	typedef _Traits                       traits_type;
	typedef typename _Traits::char_type   value_type;
	typedef _Alloc                        allocator_type;
	typedef typename _Alloc::size_type    size_type;

protected:
	/* Useful named constants */
	enum
	{
		/// For strings shorter than _S_max_copy, we copy to
		/// concatenate.
		_S_max_copy = 23,

		/// Maximal rope tree depth.
		_S_max_rope_depth = 45,

		/// For substrings longer than _S_lazy_threshold, we create
		/// substring nodes.
		_S_lazy_threshold = 128,

		/// When dumping internal structure, string printouts are
		/// cut to _S_max_printout_len characters.
		_S_max_printout_len = 40
	};

	/* Tag for simplified dynamic-like rope component casts. */
	enum class _rope_tag : uint8_t
	{
		_S_null = 0,
		_S_leaf,
		_S_concat,
		_S_substr,
		_S_func,
		_S_last_tag
	};

	static const unsigned long _S_min_len[_S_max_rope_depth + 1];

	struct _rope_rep;
	struct _rope_leaf;
	struct _rope_concat;
	struct _rope_substr;
	struct _rope_func;

	typedef counted_ptr<_rope_rep> rope_rep_ptr;
	typedef counted_ptr<_rope_leaf> rope_leaf_ptr;
	typedef counted_ptr<_rope_concat> rope_concat_ptr;
	typedef counted_ptr<_rope_substr> rope_substr_ptr;
	typedef counted_ptr<_rope_func> rope_func_ptr;

	/*
	 * Piece-wise application of functions to rope nodes may require
	 * access to allocator, which is stored externally to the actual rope
	 * node. This effectively precludes the use of virtual dispatch,
	 * as reference to the enclosing counted_ptr may be required.
	 */
	struct _rope_rep_ops
	{
		bool (*apply)(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		rope_rep_ptr (*substring)(
			rope_rep_ptr __r, size_type __begin,
			size_type __end, size_type __adj_end
		);
	};

	static const _rope_rep_ops _S_rep_ops[_rope_tag::_S_last_tag];

	/**
	 * @brief _rope_rep implementation cast.
	 *
	 * This is equivalent to dynamic_pointer_cast in functionality, but only
	 * applicable to _rope_rep derived types, for some added performance
	 * (compared to generic dynamic_cast<>).
	 */
	template <typename _Tp1, typename _Tp2>
	static counted_ptr<_Tp1> _S_rep_cast(counted_ptr<_Tp2> __p)
	{
		if ((_Tp1::_S_ref_tag == __p->_M_tag)
		    || (_Tp1::_S_ref_tag == _rope_tag::_S_null))
			return static_pointer_cast<_Tp1>(__p);
		else
			return counted_ptr<_Tp1>();
	}

	struct _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_null;

		_rope_tag _M_tag;
		uint8_t   _M_depth;
		uint8_t   _M_is_balanced;
		size_type _M_size;

		static bool _S_apply(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			return false;
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr __r, size_type __begin, size_type __end,
			size_type __adj_end
		)
		{
			return rope_rep_ptr();
		}

	protected:
		_rope_rep(_rope_tag __tag, uint8_t __d, bool __b,
			  size_type __size)
		: _M_tag(__tag), _M_depth(__d), _M_is_balanced(__b ? 1 : 0),
		  _M_size(__size)
		{}
	};

	struct _rope_leaf : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_leaf;

		enum { _S_alloc_granularity = 8 };

		_CharT _M_data[];

		static size_type _S_rounded_up_size(size_type __n)
		{
			// Allow slop for in-place expansion.
			return (((__n + 1)
				 + size_type(_S_alloc_granularity) - 1)
				& ~(size_type(_S_alloc_granularity) - 1));
		}

		_rope_leaf(size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
		}

		_rope_leaf(size_type __n, _CharT __c)
		: _rope_rep(_S_ref_tag, 0, true, __n)
		{
			traits_type::assign(_M_data, __n, __c);
			traits_type::assign(_M_data[__n], _CharT());
		}

		_rope_leaf(_CharT const *__s, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
			if (__len == 1)
				traits_type::assign(_M_data[0], *__s);
			else
				traits_type::copy(_M_data, __s, __len);

			traits_type::assign(_M_data[__len], _CharT());
		}

		static rope_leaf_ptr _S_make(size_type __len,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__len
			);
		}

		static rope_leaf_ptr _S_make(size_type __n, _CharT __c,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__n)
				),
				__n, __c
			);
		}

		static rope_leaf_ptr _S_make(_CharT const *__s, size_type __len,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__s, __len
			);
		}

		static bool _S_apply(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			rope_leaf_ptr __l(static_pointer_cast<_rope_leaf>(__r));
			return __f(__l->_M_data + __begin, __end - __begin);
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr __r, size_type __begin, size_type __end,
			size_type __adj_end
		);
	};

	struct _rope_concat : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_left;
		rope_rep_ptr _M_right;

		_rope_concat(rope_rep_ptr __l, rope_rep_ptr __r)
		: _rope_rep(
			_S_ref_tag,
			std::max(__l->_M_depth, __r->_M_depth) + 1,
			false, __l->_M_size + __r->_M_size
		 ),
		 _M_left(__l), _M_right(__r)
		{}

		static rope_concat_ptr _S_make(rope_rep_ptr __l,
					       rope_rep_ptr __r,
					       _Alloc &&__a)
		{
			return allocate_counted<_rope_concat>(
				__a, __l, __r
			);
		}

		static rope_concat_ptr _S_make(rope_rep_ptr __l,
					       rope_rep_ptr __r)
		{
			return _S_make(__l, __r, *get_allocator<_Alloc>(__l));
		}

		static bool _S_apply(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		static rope_rep_ptr _S_substring(
			rope_rep_ptr __r, size_type __begin, size_type __end,
			size_type __adj_end
		);
	};

	struct _rope_substr : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_base;
		size_type    _M_start;

		_rope_substr(rope_rep_ptr __base, size_type __start,
			     size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_base(__base),
		  _M_start(__start)
		{}

		static rope_substr_ptr _S_make(
			rope_rep_ptr __base, size_type __start,
			size_type __len, _Alloc &&__a)
		{
			return allocate_counted<_rope_substr>(
				__a, __base, __start, __len
			);
		}

		static bool _S_apply(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			rope_substr_ptr __s(
				static_pointer_cast<_rope_substr>(__r)
			);
			return rope_type::_S_apply(
				__s->_M_base, __f, __begin + __s->_M_start,
				std::min(__s->_M_size, __end)
			);
		}

		static rope_rep_ptr _S_substring(
			rope_rep_ptr __r, size_type __begin, size_type __end,
			size_type __adj_end
		);
	};

	struct _rope_func : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_func;

		std::function<void (size_type, size_type, _CharT *)> _M_fn;

		_rope_func(decltype(_M_fn) __f, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_fn(__f)
		{}

		/* _M_fn will be evaluated into a temporary leaf node,
		 * before application of __f.
		 */
		static bool _S_apply(
			rope_rep_ptr __r,
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			size_type __len(__end - __begin);
			rope_leaf_ptr __l(
				_rope_leaf::_S_make(
					__len, *get_allocator<_Alloc>(__r)
				)
			);

			static_pointer_cast<_rope_func>(__r)->_M_fn(
				__begin, __len, __l->_M_data
			);

			return __f(__l->_M_data, __len);
		}


		static rope_rep_ptr _S_substring(
			rope_rep_ptr __r, size_type __begin, size_type __end,
			size_type __adj_end
		);
	};

	/**
	 * @brief Definition of the balanced sub-tree.
	 */
	static bool _S_is_balanced(rope_rep_ptr __r)
	{
		return (__r->_M_size >= _S_min_len[__r->_M_depth]);
	}

	static rope_rep_ptr _S_concat_and_set_balanced(rope_rep_ptr __l,
						       rope_rep_ptr __r)
	{
		rope_rep_ptr __result(_S_concat(__l, __r));

		if (_S_is_balanced(__result))
			__result->_M_is_balanced = true;

		return __result;
	}

	/**
	 * @brief Add __r to forest, assuming __r is already balanced.
	 */
	static void _S_add_leaf_to_forest(rope_rep_ptr __r,
					  rope_rep_ptr *__forest);

	/**
	 * @brief Add all unbalanced subtrees to the forest of balanced trees.
	 *
	 * Used only by _S_balance.
	 */
	static void _S_add_to_forest(rope_rep_ptr __r, rope_rep_ptr *__forest);

	/**
	 * @brief The basic rebalancing operation.
	 *
	 * Logically copies the rope. The result is within height 2 of
	 * balanced by the above definition.
	 */
	static rope_rep_ptr _S_balance(rope_rep_ptr __r);

	/**
	 * @brief General concatenation on rope_rep.
	 */
	static rope_rep_ptr _S_concat(rope_rep_ptr __l, rope_rep_ptr __r);

	/**
	 * @brief Concatenation of nonempty strings.
	 *
	 * Always builds a concatenation node.
	 * Rebalances if the result is too deep.
	 */
	static rope_rep_ptr _S_tree_concat(rope_rep_ptr __l, rope_rep_ptr __r);

	/**
	 * @brief Concatenate by copying leaf.
	 */
	static rope_leaf_ptr _S_leaf_concat_char_iter(rope_leaf_ptr __r,
						      _CharT const *__s,
						      size_type __len);

	/**
	 * @brief Concatenate rope and char ptr, copying __s.
	 */
	static rope_rep_ptr _S_concat_char_iter(rope_rep_ptr __r,
						_CharT const *__s,
						size_type __len);

	/**
	 * @brief Copy substring of __r to the _CharT array.
	 *
	 * @return Pointer to the end of the array.
	 */
	static _CharT *_S_flatten(rope_rep_ptr __r, size_type __begin,
				  size_type __len, _CharT *__s);

	/**
	 * @brief Copy __r to the _CharT array.
	 *
	 * @return Pointer to the end of the array (__s + __r->_M_size).
	 */
	static _CharT *_S_flatten(rope_rep_ptr __r, _CharT *__s)
	{
		return _S_flatten(__r, 0, __r->_M_size, __s);
	}

	/**
	 * @brief Construct rope tree representing a substring of __r.
	 *
	 * Rope will be recursively traversed because of rope_concat_ptr and
	 * rope_substr_ptr semantics.
	 */
	static rope_rep_ptr _S_substring(rope_rep_ptr __r, size_type __begin,
					 size_type __end)
	{
		if (!__r)
			return __r;

		size_type __len(__r->_M_size);
		size_type __adj_end;

		if (__end >= __len) {
			if (0 == __begin)
				return __r;
			else
				__adj_end = __len;
		} else
			__adj_end = __end;

		return _S_rep_ops[static_cast<size_t>(__r->_M_tag)]
		       .substring(__r, __begin, __end, __adj_end);

	}

	/**
	 * @brief Apply __f to generic rope piece.
	 *
	 * Rope will be recursively traversed because of rope_concat_ptr and
	 * rope_substr_ptr semantics.
	 */
	static bool _S_apply(
		rope_rep_ptr __r,
		std::function<bool (_CharT const *, size_type)> __f,
		size_type __begin, size_type __end
	)
	{
		if (__r)
			return _S_rep_ops[static_cast<size_t>(__r->_M_tag)]
			       .apply(__r, __f, __begin, __end);
		else
			return true;
	}

	/**
	 * @brief Dump internal rope structure to the supplied ostream.
	 */
	static std::basic_ostream<_CharT, _Traits> &_S_dump(
		rope_rep_ptr const &__r,
		std::basic_ostream<_CharT, _Traits> &__os,
		int __indent = 0
	);

	std::tuple<rope_rep_ptr, allocator_type> _M_treeplus;

private:
	rope(rope_rep_ptr __t, _Alloc &&__a = _Alloc())
	: _M_treeplus(__t, __a)
	{}

	rope(rope_rep_ptr __t, _Alloc const &__a)
	: _M_treeplus(__t, __a)
	{}

public:
	bool empty() const
	{
		return !(_M_treeplus._M_v);
	}

	rope(_CharT const *__s, _Alloc &&__a = _Alloc())
	: _M_treeplus(
		__s ? _rope_leaf::_S_make(__s, traits_type::length(__s),
					  std::forward(__a))
		    : rope_rep_ptr(),
		std::forward(__a)
	)
	{}

	rope(_CharT const *__s, size_type __len, _Alloc &&__a = _Alloc())
	: _M_treeplus(
		__s ? _rope_leaf::_S_make(__s, __len, std::forward(__a))
		    : rope_rep_ptr(),
		std::forward(__a)
	)
	{}

	rope(size_type __n, _CharT __c, _Alloc &&__a = _Alloc());

	rope(_Alloc &&__a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{}

	~rope()
	{}

	rope &operator=(rope const &__r)
	{
		std::get<0>(_M_treeplus) = std::get<0>(__r._M_treeplus);

		return *this;
	}

	void clear()
	{
		std::get<0>(_M_treeplus).reset();
	}

	void push_back(_CharT __c)
	{
		std::get<0>(_M_treeplus)
		= _S_destr_concat_char_iter(std::get<0>(_M_treeplus), &__c, 1);
	}

	void pop_back()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus)
		= _S_substring(__old, 0, __old->_M_size - 1);
	}

	_CharT back() const
	{
		rope_rep_ptr __r(std::get<0>(_M_treeplus));

		return _S_fetch(__r, __r->_M_size - 1);
	}

	void push_front(_CharT __c)
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));
		rope_leaf_ptr __l(
			_rope_leaf::_S_make(&__c, 1, std::get<1>(_M_treeplus))
		);

		std::get<0>(_M_treeplus) = _S_concat(__l, __old);
	}

	void pop_front()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus)
		= _S_substring(__old, 1, __old->_M_size);
	}

	_CharT front() const
	{
		return _S_fetch(std::get<0>(_M_treeplus), 0);
	}

	void balance()
	{
		rope_rep_ptr __old(std::get<0>(_M_treeplus));

		std::get<0>(_M_treeplus) = _S_balance(__old);
	}

	void copy(_CharT *__s) const
	{
		_S_flatten(std::get<0>(_M_treeplus), __s);
	}

	size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const
	{
		size_type __size(this->size());
		size_type __len(__pos + __n > __size ? __size - __pos : __n);

		_S_flatten(std::get<0>(_M_treeplus), __pos, __len, __s);
		return __len;
	}

	class _rope_dumper
	{
		friend class rope;

		_rope_dumper(rope_rep_ptr __r)
		: _M_r(__r)
		{}

		std::basic_ostream<_CharT, _Traits> &_M_dump(
			std::basic_ostream<_CharT, _Traits> &__os
		) const
		{
			return rope_type::_S_dump(_M_r, __os);
		}

		friend std::basic_ostream<_CharT, _Traits> &operator<<(
			std::basic_ostream<_CharT, _Traits> &__os,
			_rope_dumper const &__d
		)
		{
			return __d._M_dump(__os);
		}

		rope_rep_ptr _M_r;
	};

	/**
	 * @brief Expose internal rope structure.
	 *
	 * Useful primarily for debugging.
	 * @return Proxy object which can be printed to ostream interface.
	 */
	_rope_dumper dump()
	{
		 return _rope_dumper(std::get<0>(_M_treeplus));
	}


	size_type size() const
	{
		if (std::get<0>(_M_treeplus))
			return std::get<0>(_M_treeplus)->_M_size;
		else
			return 0;
	}

	rope &operator+=(rope const &__r)
	{
		return append(__r);
	}

	rope &append(rope const &__r)
	{
		rope_rep_ptr __result(_S_concat(std::get<0>(_M_treeplus),
						std::get<0>(__r._M_treeplus)));
		std::get<0>(_M_treeplus) = __result;
		return *this;
	}

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 const *__r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 __r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend std::basic_ostream<_CharT2, _Traits2> &operator<<(
		std::basic_ostream<_CharT2, _Traits2> &__os,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);
};

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	rope<_CharT, _Traits, _Alloc> const &__r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	return rope_type(
		rope_type::_S_concat(std::get<0>(__l._M_treeplus),
				     std::get<0>(__r._M_treeplus)),
		std::get<1>(__l._M_treeplus)
	);
}

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT const *__r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;
	typedef typename rope_type::size_type size_type;

	size_type __rlen(rope_type::traits_type::length(__r));

	return rope_type(
		__l._S_concat_char_iter(__l._M_treeplus._M_v, __r, __rlen),
		__l._M_treeplus
	);

}

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT __r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	return rope_type(
		__l._S_concat_char_iter(__l._M_treeplus._M_v, &__r, 1),
		__l._M_treeplus
	);
}

template<typename _CharT, typename _Traits, typename _Alloc>
std::basic_ostream<_CharT, _Traits> &operator<<(
	std::basic_ostream<_CharT, _Traits> &__os,
	rope<_CharT, _Traits, _Alloc> const &__r
);

typedef rope<char> crope;
typedef rope<wchar_t> wrope;

#ifndef _GLIBCXX_EXPORT_TEMPLATE
#include <rope.tcc>
#endif

#endif
