// Reimplementation of SGI's rope class -*- C++ -*-

// Copyright (C) 2010 Alex Dubov <oakad@yahoo.com>
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3, or
// (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.


// Derived from original implementation
// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
// Free Software Foundation, Inc.

// May contain parts
// Copyright (c) 1997
// Silicon Graphics Computer Systems, Inc.

// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear
// in supporting documentation.  Silicon Graphics makes no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied warranty.

#ifndef _EXT_ROPE
#define _EXT_ROPE 1

#include <iterator>
#include <counted_ptr.h>

template< typename _CharT, typename _Traits = std::char_traits<_CharT>,
	  typename _Alloc = std::allocator<_CharT> >
struct rope;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_iterator;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_const_iterator;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_char_ref_proxy;

template<typename _CharT, typename _Traits, typename _Alloc>
class _rope_char_ptr_proxy;

template<typename _CharT, typename _Traits, typename _Alloc>
bool operator==(
	const _rope_char_ptr_proxy<_CharT, _Traits, _Alloc>& __x,
	const _rope_char_ptr_proxy<_CharT, _Traits, _Alloc>& __y
);
/*
template<typename _CharT, typename _Traits, typename _Alloc>
_rope_const_iterator<_CharT, _Traits, _Alloc> operator-(
	const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	ptrdiff_t __n
);

template<typename _CharT, typename _Traits, typename _Alloc>
_rope_const_iterator<_CharT, _Traits, _Alloc> operator+(
	const _rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_const_iterator<_CharT, _Traits, _Alloc>
    operator+(ptrdiff_t __n,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x);

  template<class _CharT, class _Alloc>
    bool
    operator==(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	       const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    bool
    operator<(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    ptrdiff_t
    operator-(const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_const_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator-(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x, ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator+(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x, ptrdiff_t __n);

  template<class _CharT, class _Alloc>
    _Rope_iterator<_CharT, _Traits, _Alloc>
    operator+(ptrdiff_t __n, const _Rope_iterator<_CharT, _Traits, _Alloc>& __x);

  template<class _CharT, class _Alloc>
    bool
    operator==(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	       const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    bool
    operator<(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);

  template<class _CharT, class _Alloc>
    ptrdiff_t
    operator-(const _Rope_iterator<_CharT, _Traits, _Alloc>& __x,
	      const _Rope_iterator<_CharT, _Traits, _Alloc>& __y);




template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__left,
	_CharT const *__right
);

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__left,
	_CharT __right
);
*/

template<typename _CharT, typename _Traits, typename _Alloc>
struct rope
{
protected:
	typedef typename _Alloc::template rebind<_CharT>::other
	_CharT_alloc_type;

public:
	typedef _Traits                               traits_type;
	typedef typename _Traits::char_type           value_type;
	typedef _Alloc                                allocator_type;
	typedef typename _CharT_alloc_type::size_type size_type;

protected:
	/* Useful named constants */
	enum
	{
		/// For strings shorter than _S_copy_max, we copy to
		/// concatenate.
		_S_copy_max = 23,

		/// Maximal rope tree depth.
		_S_max_rope_depth = 45
	};

	/* Tag for simplified dynamic-like rope component casts. */
	enum class _rope_tag : uint8_t
	{
		_S_null = 0,
		_S_leaf,
		_S_concat,
		_S_substr,
		_S_func
	};

	static const unsigned long _S_min_len[_S_max_rope_depth + 1];

	struct _rope_rep;
	struct _rope_leaf;
	struct _rope_concat;
	struct _rope_substr;
	struct _rope_func;

	typedef counted_ptr<_rope_rep> rope_rep_ptr;
	typedef counted_ptr<_rope_leaf> rope_leaf_ptr;
	typedef counted_ptr<_rope_concat> rope_concat_ptr;
	typedef counted_ptr<_rope_substr> rope_substr_ptr;
	typedef counted_ptr<_rope_func> rope_func_ptr;

	/**
	 * @brief _rope_rep implementation cast.
	 *
	 * This is equivalent to dynamic_pointer_cast in functionality, but only
	 * applicable to _rope_rep derived types, for some added performance
	 * (compared to generic dynamic_cast<>).
	 */
	template <typename _Tp1, typename _Tp2>
	static counted_ptr<_Tp1> _S_rep_cast(counted_ptr<_Tp2> __p)
	{
		if ((_Tp1::_S_ref_tag == __p->_M_tag)
		    || (_Tp1::_S_ref_tag == _rope_tag::_S_null))
			return static_pointer_cast<_Tp1>(__p);
		else
			return counted_ptr<_Tp1>();
	}

	struct _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_null;

		_rope_tag _M_tag;
		uint8_t   _M_depth;
		uint8_t   _M_is_balanced;
		size_type _M_size;

		virtual ~_rope_rep()
		{}

		virtual bool _M_apply(
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		)
		{
			return false;
		}

	protected:
		_rope_rep(_rope_tag __tag, uint8_t __d, bool __b,
			  size_type __size)
		: _M_tag(__tag), _M_depth(__d), _M_is_balanced(__b ? 1 : 0),
		  _M_size(__size)
		{}
	};

	struct _rope_leaf : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_leaf;

		enum { _S_alloc_granularity = 8 };

		_CharT _M_data[];

		static size_type _S_rounded_up_size(size_type __n)
		{
			// Allow slop for in-place expansion.
			return (((__n + 1)
				 + size_type(_S_alloc_granularity) - 1)
				& ~(size_type(_S_alloc_granularity) - 1));
		}

		_rope_leaf(size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
		}

		_rope_leaf(size_type __n, _CharT __c)
		: _rope_rep(_S_ref_tag, 0, true, __n)
		{
			traits_type::assign(_M_data, __n, __c);
			traits_type::assign(_M_data[__n], _CharT());
		}

		_rope_leaf(_CharT const *__s, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len)
		{
			if (__len == 1)
				traits_type::assign(&_M_data[0], *__s);
			else
				traits_type::copy(_M_data, __s, __len);

			traits_type::assign(_M_data[__len], _CharT());
		}

		virtual ~_rope_leaf()
		{
		}

		virtual bool _M_apply(
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		static rope_leaf_ptr _S_make(size_type __len,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__len
			);
		}

		static rope_leaf_ptr _S_make(size_type __n, _CharT __c,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				typename rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__n)
				),
				__n, __c
			);
		}

		static rope_leaf_ptr _S_make(_CharT const *__s, size_type __len,
					     _Alloc &&__a)
		{
			return allocate_counted<_rope_leaf>(
				__a,
				rope_leaf_ptr::extra_size(
					_S_rounded_up_size(__len)
				),
				__s, __len
			);
		}
	};

	struct _rope_concat : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_left;
		rope_rep_ptr _M_right;

		_rope_concat(rope_rep_ptr __l, rope_rep_ptr __r)
		: _rope_rep(
			_S_ref_tag,
			std::max(__l->_M_depth, __r->_M_depth) + 1,
			false, __l->_M_size + __r->_M_size
		 ),
		 _M_left(__l), _M_right(__r)
		{}

		virtual ~_rope_concat()
		{}

		virtual bool _M_apply(
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);

		static rope_concat_ptr _S_make(rope_rep_ptr __l,
					       rope_rep_ptr __r,
					       _Alloc &&__a)
		{
			return allocate_counted<_rope_concat>(
				__a, __l, __r
			);
		}

		static rope_concat_ptr _S_make(rope_rep_ptr __l,
					       rope_rep_ptr __r)
		{
			return _S_make(__l, __r, *get_allocator<_Alloc>(__l));
		}
	};

	struct _rope_substr : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_concat;

		rope_rep_ptr _M_base;
		size_type    _M_start;

		_rope_substr(rope_rep_ptr __base, size_type __start,
			     size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_base(__base),
		  _M_start(__start)
		{}

		virtual ~_rope_substr()
		{}

		virtual bool _M_apply(
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);
	};

	struct _rope_func : public _rope_rep
	{
		static const _rope_tag _S_ref_tag = _rope_tag::_S_func;

		std::function<void (size_type, size_type, _CharT *)> _M_fn;

		_rope_func(decltype(_M_fn) __f, size_type __len)
		: _rope_rep(_S_ref_tag, 0, true, __len), _M_fn(__f)
		{}

		virtual ~_rope_func()
		{}

		virtual bool _M_apply(
			std::function<bool (_CharT const *, size_type)> __f,
			size_type __begin, size_type __end
		);
	};

	/**
	 * @brief Definition of the balanced sub-tree.
	 */
	static bool _S_is_balanced(rope_rep_ptr __r)
	{
		return (__r->_M_size >= _S_min_len[__r->_M_depth]);
	}

	static rope_rep_ptr _S_concat_and_set_balanced(rope_rep_ptr __l,
						       rope_rep_ptr __r)
	{
		rope_rep_ptr __result(_S_concat(__l, __r));

		if (_S_is_balanced(__result))
			__result->_M_is_balanced = true;

		return __result;
	}

	/**
	 * @brief Add __r to forest, assuming __r is already balanced.
	 */
	static void _S_add_leaf_to_forest(rope_rep_ptr __r,
					  rope_rep_ptr *__forest);

	/**
	 * @brief Add all unbalanced subtrees to the forest of balanced trees.
	 *
	 * Used only by _S_balance.
	 */
	static void _S_add_to_forest(rope_rep_ptr __r, rope_rep_ptr *__forest);

	/**
	 * @brief The basic rebalancing operation.
	 *
	 * Logically copies the rope. The result is within height 2 of
	 * balanced by the above definition.
	 */
	static rope_rep_ptr _S_balance(rope_rep_ptr __r);

	/**
	 * @brief General concatenation on rope_rep.
	 */
	static rope_rep_ptr _S_concat(rope_rep_ptr __l, rope_rep_ptr __r);

	/**
	 * @brief Concatenation of nonempty strings.
	 *
	 * Always builds a concatenation node.
	 * Rebalances if the result is too deep.
	 */
	static rope_rep_ptr _S_tree_concat(rope_rep_ptr __l, rope_rep_ptr __r);

	/**
	 * @brief Concatenate by copying leaf.
	 */
	static rope_leaf_ptr _S_leaf_concat_char_iter(rope_leaf_ptr __r,
						      _CharT const *__s,
						      size_type __len);

	/**
	* @brief Concatenate rope and char ptr, copying __s.
	*/
	static rope_rep_ptr _S_concat_char_iter(rope_rep_ptr __r,
						_CharT const *__s,
						size_type __len);

	/**
	 * @brief Traverse tree, applying __f to matching character ranges.
	 */
	static bool _S_apply_to_pieces(
		std::function<bool (_CharT const *, size_type)> __f,
		rope_rep_ptr __r, size_type __begin,
		size_type __end
	)
	{
		if (!__r)
			return true;
		else
			__r->_M_apply(__f, __begin, __end);
	}

	std::tuple<rope_rep_ptr, allocator_type> _M_treeplus;

private:
	rope(rope_rep_ptr __t, _Alloc &&__a = _Alloc())
	: _M_treeplus(__t, __a)
	{}

	rope(rope_rep_ptr __t, _Alloc const &__a)
	: _M_treeplus(__t, __a)
	{}

public:
	bool empty() const
	{
		return !(_M_treeplus._M_v);
	}

	rope(_CharT const *__s, _Alloc &&__a = _Alloc())
	: _M_treeplus(
		__s ? _rope_leaf::_S_make(__s, traits_type::length(__s),
					  std::forward(__a))
		    : rope_rep_ptr(),
		std::forward(__a)
	)
	{}

	rope(_CharT const *__s, size_type __len, _Alloc &&__a = _Alloc())
	: _M_treeplus(
		__s ? _rope_leaf::_S_make(__s, __len, std::forward(__a))
		    : rope_rep_ptr(),
		std::forward(__a)
	)
	{}

	rope(size_type __n, _CharT __c, _Alloc &&__a = _Alloc());

	rope(_Alloc &&__a = _Alloc())
	: _M_treeplus(rope_rep_ptr(), __a)
	{}

	size_type size() const
	{
		if (std::get<0>(_M_treeplus))
			return std::get<0>(_M_treeplus)->_M_size;
		else
			return 0;
	}

	rope &operator+=(rope const &__r)
	{
		return append(__r);
	}

	rope &append(rope const &__r)
	{
		rope_rep_ptr __result(_S_concat(std::get<0>(_M_treeplus),
						std::get<0>(__r._M_treeplus)));
		std::get<0>(_M_treeplus) = __result;
		return *this;
	}

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 const *__r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend rope<_CharT2, _Traits2, _Alloc2> operator+(
		rope<_CharT2, _Traits2, _Alloc2> const &__l,
		_CharT2 __r
	);

	template<typename _CharT2, typename _Traits2, typename _Alloc2>
	friend std::basic_ostream<_CharT2, _Traits2> &operator<<(
		std::basic_ostream<_CharT2, _Traits2> &__os,
		rope<_CharT2, _Traits2, _Alloc2> const &__r
	);
};

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	rope<_CharT, _Traits, _Alloc> const &__r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	return rope_type(
		rope_type::_S_concat(std::get<0>(__l._M_treeplus),
				     std::get<0>(__r._M_treeplus)),
		std::get<1>(__l._M_treeplus)
	);
}

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT const *__r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;
	typedef typename rope_type::size_type size_type;

	size_type __rlen(rope_type::traits_type::length(__r));

	return rope_type(
		__l._S_concat_char_iter(__l._M_treeplus._M_v, __r, __rlen),
		__l._M_treeplus
	);

}

template<typename _CharT, typename _Traits, typename _Alloc>
rope<_CharT, _Traits, _Alloc> operator+(
	rope<_CharT, _Traits, _Alloc> const &__l,
	_CharT __r
)
{
	typedef rope<_CharT, _Traits, _Alloc> rope_type;

	return rope_type(
		__l._S_concat_char_iter(__l._M_treeplus._M_v, &__r, 1),
		__l._M_treeplus
	);
}

template<typename _CharT, typename _Traits, typename _Alloc>
std::basic_ostream<_CharT, _Traits> &operator<<(
	std::basic_ostream<_CharT, _Traits> &__os,
	rope<_CharT, _Traits, _Alloc> const &__r
);

typedef rope<char> crope;
typedef rope<wchar_t> wrope;

#ifndef _GLIBCXX_EXPORT_TEMPLATE
#include <rope.tcc>
#endif

#endif
